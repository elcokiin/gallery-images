name: CI/CD Pipeline

on:
  push:
    branches:
      - main # Despliegue continuo a producción cuando se fusiona en main
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - develop # Integración continua para PRs que van a develop

permissions:
  contents: read # Necesario para actions/checkout
  id-token: write # Necesario para autenticación
  pull-requests: read # Importante para los eventos de PR

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
  GAR_REPOSITORY: ${{ secrets.GAR_REPOSITORY }}
  CLOUD_RUN_SERVICE_NAME: ${{ secrets.CLOUD_RUN_SERVICE_NAME }}
  # Variables para SSH
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USERNAME: ${{ secrets.SSH_USERNAME }}

jobs:
  ci:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install dependencies
      run: npm install --production=false

    - name: Run Tests
      run: npm test
      env:
        GOOGLE_APPLICATION_CREDENTIALS: /tmp/dummy_credentials.json
        GOOGLE_CLOUD_PROJECT: dummy-project-id 

  cd:
    name: Deploy via SSH
    runs-on: ubuntu-latest
    needs: ci
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    environment:
      name: Production

    # Variables de entorno para el job CD (SSH y GCP)
    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
      # Variables GCP necesarias para referenciar el proyecto/ubicaciones, NO credenciales directas aquí
      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }} # Asegúrate de que esto está en secrets
      GAR_LOCATION: ${{ secrets.GAR_LOCATION }} # Asegúrate de que esto está en secrets
      GAR_REPOSITORY: ${{ secrets.GAR_REPOSITORY }} # Asegúrate de que esto está en secrets
      CLOUD_RUN_SERVICE_NAME: ${{ secrets.CLOUD_RUN_SERVICE_NAME }} # Asegúrate de que esto está en secrets

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # --- Paso 1: Crear archivo de credenciales en el runner ---
    # Guarda el contenido del secret en un archivo temporal en el runner
    - name: Create GCP Credentials File on Runner
      run: echo '${{ secrets.GCP_SA_KEY_CI_CD }}' > /home/runner/gcp_credentials.json # Guarda en home del runner
      # Asegúrate de que el secret está bien formateado (JSON en una sola línea o manejado por la acción auth)
      # La acción google-github-actions/auth@v1 maneja mejor esto, pero si usas el secret directamente,
      # echo es una forma, aunque puede tener problemas con newlines/escaping si el JSON no es una línea.
      # Si usas google-github-actions/auth@v1, puedes obtener la ruta temporal que crea:
      # - name: Authenticate to Google Cloud
      #   id: 'auth'
      #   uses: 'google-github-actions/auth@v1'
      #   with:
      #     credentials_json: '${{ secrets.GCP_SA_KEY_CI_CD }}'
      # - name: Get Credentials Path (if using auth@v1)
      #   run: |
      #     echo "GCP_CREDENTIALS_PATH=${{ steps.auth.outputs.credentials_file_path }}" >> $GITHUB_ENV
      #   shell: bash
      # Y luego usar ${{ env.GCP_CREDENTIALS_PATH }} en el paso de copia SCP.
      # Para simplicidad, mantendremos el `echo` directo, pero google-github-actions/auth es más robusto.


    # --- Paso 2: Configurar Agente SSH con Clave Privada ---
    - name: Setup SSH Agent
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    # --- Paso 3: Transferir Archivos de Código Y Credenciales al Servidor ---
    - name: Copy files via SCP
      run: |
        # Exporta la variable PATH para ssh/scp
        export PATH=$PATH:/home/app_deployer/.nvm/versions/node/v22.15.0/bin # <--- Asegúrate que esta es la ruta correcta
        echo "Verifying PATH: $(echo $PATH)" # Debug: Check PATH
        echo "Verifying Node existence: $(which node)" # Debug: Check if node is found
        echo "Verifying NPM existence: $(which npm)" # Debug: Check if npm is found

        # Asegúrate de que el directorio de la aplicación existe en el servidor
        ssh -o StrictHostKeyChecking=no ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }} "mkdir -p /home/${{ env.SSH_USERNAME }}/my-app"
        # Asegúrate de que el directorio para guardar credenciales existe en el servidor
        ssh -o StrictHostKeyChecking=no ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }} "mkdir -p /home/${{ env.SSH_USERNAME }}/.gcp"


        # Copia los archivos de código de la aplicación
        echo "Copying application files..."
        scp -r -o StrictHostKeyChecking=no \
            ./* \
            ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }}:/home/${{ env.SSH_USERNAME }}/my-app/

        # Copia el archivo de credenciales al servidor en una ubicación segura
        echo "Copying GCP credentials file..."
        scp -o StrictHostKeyChecking=no \
            /home/runner/gcp_credentials.json \ # Archivo temporal en el runner
            ${{ env.SSH_USERNAME }}@${{ env.SSH_HOST }}:/home/${{ env.SSH_USERNAME }}/.gcp/credentials.json # Destino seguro en el servidor

        echo "File copy completed."

    # --- Paso 4: Instalar Dependencias en el Servidor ---
    - name: Install dependencies on server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.SSH_HOST }}
        username: ${{ env.SSH_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Exporta la variable PATH para asegurar que 'npm' se encuentra
          export PATH=$PATH:/home/app_deployer/.nvm/versions/node/v22.15.0/bin # <--- Asegúrate que esta es la ruta correcta

          echo "Verifying PATH before npm install: $(echo $PATH)" # Debug
          echo "Verifying Node existence before npm install: $(which node)" # Debug
          echo "Verifying NPM existence before npm install: $(which npm)" # Debug

          cd /home/${{ env.SSH_USERNAME }}/my-app
          npm install --production
          echo "npm install completed."

    # --- Paso 5: Reiniciar la Aplicación en el Servidor (usando PM2) ---
    - name: Restart application on server (PM2)
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ env.SSH_HOST }}
        username: ${{ env.SSH_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Exporta la variable PATH para asegurar que 'pm2' y 'node'/'npm' se encuentran
          export PATH=$PATH:/home/app_deployer/.nvm/versions/node/v22.15.0/bin # <--- Asegúrate que esta es la ruta correcta

          echo "Verifying PATH before PM2 command: $(echo $PATH)" # Debug
          echo "Verifying PM2 existence: $(which pm2)" # Debug

          cd /home/${{ env.SSH_USERNAME }}/my-app

          # --- ¡CRUCIAL! Establece la variable de entorno GOOGLE_APPLICATION_CREDENTIALS para el proceso PM2 ---
          # La ruta debe ser la ubicación en el servidor donde copiaste el archivo de credenciales.
          export GOOGLE_APPLICATION_CREDENTIALS="/home/${{ env.SSH_USERNAME }}/.gcp/credentials.json" # <--- Establece la variable

          echo "GOOGLE_APPLICATION_CREDENTIALS set to: $GOOGLE_APPLICATION_CREDENTIALS" # Debug

          # Ahora inicia o reinicia la aplicación con PM2.
          # PM2 heredará la variable de entorno exportada JUSTO ANTES de su ejecución.
          # --update-env asegura que si la app ya estaba corriendo, PM2 la reinicie con las env vars actuales.
          # --env production es buena práctica para Node.js
          pm2 start server.js --name my-app --update-env --env production || pm2 restart my-app --update-env

          echo "PM2 command executed. Saving PM2 state..."
          pm2 save # Guarda el estado de PM2

          echo "Restart step completed."


    # --- Paso Opcional: Mostrar mensaje de éxito ---
    - name: Deployment Successful
      run: echo "Despliegue a ${{ env.SSH_HOST }} completado para la versión ${{ github.sha }}"
